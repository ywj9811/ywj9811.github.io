---
title: Spring Transaction 옵션
date: '2022-12-22'
tags: ['spring boot', 'Transaction', '인프런', '김영한', '기술']
draft: false
summary: 스프링 트랜잭션에서는 다양한 옵션을 제공하고 있으며 이 다양한 옵션에 대해서 한번 살펴보도록 하자.
---

## 스프링 트랜잭션 옵션 소개

**스프링 트랜잭션에서 제공하는 다양한 옵션에 대해서 살펴보도록 하자.**

### **value, transactionManager**

    **트랜잭션을 사용하려면 먼저 스프링 빈에 등록된 어떤 트랜잭션 매니저를 사용할지 알아야 한다.**

    **`@Transactional` 에서도 트랜잭션 프록시가 사용할 트랜잭션 매니저를 지정해주어야 한다.**

    **사용할 트랜잭션 매니저를 지정할 때는 `value`, `transactionManager` 둘 중 하나에 트랜잭션 매니저의 스프링 빈의 이름을 적어주면 된다.**

    **물론 기본으로 등록된 트랜잭션 매니저가 기본으로 사용되기 때문에 대부분 생략하고 진행한다.**

    **하지만 두개 이생의 트랜잭션 매니저를 사용하는 상황에는 구분하여 사용하도록 하자.**

    ```java
    public class TxService {
    	@Transactional("memberTxManager")
    	public void member() {...}

    	@Transactional("orderTxManager")
    	public void order() {...}
    }
    ```

    **이렇게 사용하는 것으로 위와 같이 속성이 하나인 경우 `value`를 생략할 수 있다.**

---

### **rollbackFor**

    > **예외 발생시 스프링 트랜잭션의 기본 정책은 다음과 같다.**
    >
    > - **언체크 예외인 `RuntimeException`, `Error` 와 그 하위 예외가 발생하면 롤백**
    > - **체크 예외인 `Exception` 과 그 하위 예외들은 커밋**

    **이 옵션을 사용하면 기본 정책에 추가로 어떤 예외가 발생할 때 롤백하도록 지정할 수 있다.**

    ```java
    @Transactional(rollbackFor = Exception.class)
    ```

    **예를 들어 위와 같이 `Exception` 이 발생해도 롤백하게 할 수 있다.(하위 예외 모두 롤백)**

    **rollbackForClassName이라는 것도 있는데 이는 예외 이름을 문자로 넣어주면 되는 것으로 rollbackFor과 같은 기능을 한다.**

---

### **noRollbackFor**

    **rollbackFor와 반대의 기능을 가지고 있다.**

    **기본 정책에 추가로 어떤 예외가 발생했을 때 롤백하지 않도록 한다.**

    **마찬가지로 noRollbackForClassName 도 있다.**

---

### **propagation**

    **트랜잭션 전파에 대한 옵션이다. (자세한 내용은 추후에 설명)**

---

### **isolation**

    **트랜잭션 격리 수준을 지정할 수 있다.**

    **기본 값은 데이터베이스에서 설정한 트랜잭션 격리 수준을 사용하는 `DEFAULT` 이다.**

    **대부분 데이터베이스에서 설정한 기준을 따르기 때문에 많이 사용하지는 않는다.**

    - **`DEFAULT` : 데이터베이스에서 설정한 격리 수준 따른다.**
    - **`READ_UNCOMMITED` : 커밋되지 않은 읽기**
    - **`READ_COMMIT` : 커밋된 읽기(주로 사용)**
    - **`REPEATABLE_READ` : 반복 가능한 읽기**
    - **`SERIALIZABLE` : 직렬화 기능**

---

### **timeout**

    **트랜잭션 수행 시간에 대한 타임아웃을 초 단위로 지정한다.**

    **기본 값은 트랜잭션 시스템의 타임아웃을 사용한다.**

    **운영 환경에 따라 동작하는 경우도 있고 그렇지 않은 경우도 있기 때문에 꼭 확인하고 사용하도록 하자.**

    **timeoutString 도 있는데 이는 숫자 대신 문자 값으로 지정하는 것이다.**

---

### **label**

    **트랜잭션 어노테이션에 있는 값을 직접 읽어서 어떤 동작을 하고 싶을 때 사용할 수 있다. (일반적으로 사용하지 않음)**

---

### **readOnly**

    **이전에 테스트 코드에서 사용하기도 했던 것으로 트랜잭션은 기본적으로 읽기 쓰기 모두 가능한 트랜잭션으로 생성된다.**

    **`readOnly=true` 옵션을 사용하게 되면 읽기 전용 트랜잭션이 생성된다.**

    **이 경우 등록, 수정, 삭제가 안되고 오로지 조회 기능만 작동한다.**

    **그리고 readOnly 옵션을 사용하면 읽기에서 다양한 성능 최적화가 가능하다.**

    **이는 크게 3곳에서 작용한다.**

    1. **프레임워크**
        - **JdbcTemplate는 읽기 전용 트랜잭션 안에서 변경 기능을 실행하면 예외를 던진다.**
        - **JPA(하이버네이트)는 읽기 전용 트랜잭션의 경우 커밋 시점에 플러시를 호출하지 않는다.**

            **읽기 전용이니 변경에 사용되는 플러시를 호출할 필요가 없다.**

            **추가로 변경이 필요 없으니 변경 감지를 위한 스냅샷 객체도 생성하지 않는다.**

            **이와 같이 JPA에서는 다양한 최적화가 발생한다.**

    2. **JDBC 드라이버**
        - **참고로 여기서 설명하는 내용들은 DB와 드라이버 버전에 따라서 다르게 동작하기 때문에 사전에 확인이 필요하다.**
        - **읽기 전용 트랜잭션에서 변경 쿼리가 발생하면 예외를 던진다.**
        - **읽기, 쓰기 데이터베이스를 구분해서 요청한다.**

            **읽기 전용 트랜잭션의 경우 읽기 데이터베이스의 커넥션을 획득해서 사용한다.**

    3. **데이터베이스**
        - **데이터베이스에 따라 읽기 전용 트랜잭션의 경우 읽기만 하면 되므로, 내부에서 성능 최적화가 발생한다.**
